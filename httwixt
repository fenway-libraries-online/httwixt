#!/usr/bin/perl

use strict;
use warnings;

sub usage;
sub fatal;

use HTTP::Request;
use Digest;
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

use constant REQLENLIMIT => 1<<16;  # Max. 64KB

my %reason = (
    200 => 'OK',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Time-out',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Large',
    415 => 'Unsupported Media Type',
    416 => 'Requested range not satisfiable',
    417 => 'Expectation Failed',
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Time-out',
    505 => 'HTTP Version not supported',
);

my $www  = $ENV{'HTTWIXT_URI'} || 'http://localhost';
my $root = $ENV{'HTTWIXT_ROOT'} || '/var/local/httwixt';
my ($pub, $prv) = qw(public private);
my $red  = '302';

GetOptions(
    'u|uri-base=s' => \$www,
    'r|root=s' => \$root,
    'p|public=s' => \$pub,
    'q|private=s' => \$prv,
    's|redirect-status=i' => \$red,
) or usage;

$pub = "$root/$pub" if $pub !~ m{^/};
$prv = "$root/$prv" if $prv !~ m{^/};

fatal "no such directory: $root" if !-d $root;
fatal "no such directory: $pub"  if !-d $pub;
fatal "no such directory: $prv"  if !-d $prv;

usage if $red !~ /^3[0-9][0-9]$/;

my ($hash, $url, $tpl);
eval {
    # Read the HTTP request
    my ($buf, $dig);
    my $n = read(STDIN, $buf, REQLENLIMIT) or die;
    die if $n == REQLENLIMIT;
    my $req = HTTP::Request->parse($buf);
    die if $req->method ne 'GET';
    my $path = $req->uri->path;
    die if $path !~ m{/(.+)/([^/\s]+)$};
    my ($coll, $file) = ($1, $2);
    # Publish the desired file under a "random" URL
    die if !-e "$prv/$coll/$file";
    foreach (qw(SHA-256 SHA-1 MD5)) {
        last if $dig = eval { Digest->new($_) }
    }
    die if !$dig;
    $hash = substr $dig->add(time, $$, rand)->hexdigest, 0, 32;
    die if !mkdir "$pub/$hash"
        or !symlink "$prv/$coll/$file", "$pub/$hash/$file";
    my $tfile = find_template($coll, $file);
    if (defined $tfile) {
        open my $fh, '<', $tfile or die;
        local $/;
        $tpl = <$fh>;
        die if !defined $tpl;
    }
    $url = sprintf '%s/%s/%s', $www, $hash, $file;
    print STDERR "httwixt: published $prv$path as $pub/$hash/$file\n";
};
if (defined $tpl) {
    my $html = process_template(\$tpl, {
        url => $url,
        root => $root,
        public => $pub,
        private => $prv,
        hash => $hash,
    });
    send_response(200, \$html);
}
elsif (defined $url) {
    send_response($red, { Location => $url }, \'<html>Found</html>');
}
else {
    send_response(404, \'<html>Not found</html>');
}

sub find_template {
    my ($coll, $file) = @_;
    my $dir = "$prv/$coll";
    (my $base = $file) =~ s/\.([^.]+)$//;
    my ($tfile) = (
        glob("$dir/$base.html"),
        glob("$dir/default-template.html"),
    );
    return $tfile;
}

sub process_template {
    my ($tplref, $vars) = @_;
    (my $out = $$tplref) =~ s/{{(\w+)}}/$vars->{$1} || ''/eg;
    return $out;
}

sub send_response {
    my $status = shift;
    my ($header, $ctype, $cref) = ({}, 'text/html', \'');
    foreach (@_) {
        my $r = ref $_;
        $header = $_, next if $r eq 'HASH';
        $ctype  = $_, next if $r eq '';
        $cref   = $_, next if $r eq 'SCALAR';
        die;
    }
    my $clen = length $$cref;
    my $reason = $reason{$status} || 'mumble';
    my @out = (
        "HTTP/1.0 $status $reason",
        "Content-Type: $ctype",
        "Content-Length: $clen",
    );
    while (my ($k, $v) = each %$header) {
        push @out, "$k: $v";
    }
    push @out, '';
    print $_, "\x0d\x0a" for @out;
    print $$cref;
}

